% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/coverage_correlation.R
\name{coverage_correlation}
\alias{coverage_correlation}
\title{Coverage-based dependence measure with optional visualisation}
\usage{
coverage_correlation(
  x,
  y,
  visualise = FALSE,
  method = c("auto", "exact", "approx"),
  M = NULL
)
}
\arguments{
\item{x}{Numeric vector or matrix.}

\item{y}{Numeric vector or matrix of the same number of rows as \code{x}.
Will be coerced to a matrix and ranked.}

\item{visualise}{Logical; if \code{TRUE}, scatter the rank points and overlay
rectangles. Default \code{FALSE}.}
}
\value{
A \code{units} scalar giving the area (coverage) of the union of the
  rectangles; use \code{as.numeric()} to obtain a plain numeric.
}
\description{
Constructs small squares around the rank-transformed samples
\eqn{(r_x, r_y)} on \eqn{[0,1]^2}, splits them by shifts in
\eqn{\{-1,0,1\}^d} and clips to \eqn{[0,1]^d}, and returns the union area of
the resulting rectangles. Optionally plots the points and rectangles.
}
\details{
Let \eqn{n} be the number of rows after coercion, and
\eqn{d = d_x + d_y} the total number of columns across \code{x} and \code{y}.
Square half-widths are set to \eqn{\varepsilon = \frac{1}{2} n^{-1/d}} in each
dimension. Ranks are scaled to \eqn{(0,1)} using independent sorted uniforms,
producing a smoothed rank transform.
}
\examples{
set.seed(1)
n <- 1000
x <- runif(n)
y <- sin(3*x) + runif(n) * 0.01
coverage_correlation(x, y, TRUE)

}
\seealso{
\code{\link{split_rectangles}}, \code{\link{plot_rectangles}},
  \code{\link{union_area}}
}
